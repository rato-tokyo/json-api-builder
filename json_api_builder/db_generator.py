# json_api_builder/db_generator.py
import asyncio
import json
import os
import warnings
from pathlib import Path

from sqlalchemy.ext.asyncio import AsyncEngine, AsyncSession, create_async_engine
from sqlmodel import SQLModel


async def import_from_json_async(
    model: type[SQLModel], json_path: Path | str, engine: AsyncEngine
) -> None:
    """
    Asynchronously populates the database from a single JSON file.
    The 'id' for each record is ignored and auto-generated by the database.

    Args:
        model: The SQLModel class for the table.
        json_path: The path to the input JSON file.
        engine: The SQLAlchemy AsyncEngine instance.
    """
    async with AsyncSession(engine) as session:
        with open(json_path, encoding="utf-8") as f:
            records = json.load(f)
            if not isinstance(records, list):
                raise TypeError("JSON file must contain a list of records.")

            for record_data in records:
                if "id" in record_data:
                    del record_data["id"]

                db_item = model.model_validate(record_data)
                session.add(db_item)

        await session.commit()


def generate_db_from_json_file(
    model: type[SQLModel],
    json_path: Path | str,
    db_path: str,
    overwrite: bool = False,
) -> None:
    """
    (Deprecated) Populates the database from a JSON file.
    This function is synchronous and may cause issues in async environments.
    Prefer using an API endpoint with `import_from_json_async`.
    """
    warnings.warn(
        (
            "`generate_db_from_json_file` is deprecated and will be removed in a future version. "
            "It is recommended to create a custom API endpoint that calls `import_from_json_async` "
            "to avoid potential event loop conflicts."
        ),
        DeprecationWarning,
        stacklevel=2,
    )

    if overwrite and os.path.exists(db_path):
        os.remove(db_path)

    engine = create_async_engine(f"sqlite+aiosqlite:///{db_path}")

    async def _run_import():
        async with engine.begin() as conn:
            await conn.run_sync(SQLModel.metadata.create_all)
        await import_from_json_async(model, json_path, engine)
        await engine.dispose()

    try:
        loop = asyncio.get_running_loop()
        if loop.is_running():
            warnings.warn(
                "An existing event loop is running. "
                "Calling `generate_db_from_json_file` from an async context can lead to deadlocks. "
                "Consider creating a separate script for this operation or use an API endpoint.",
                UserWarning,
                stacklevel=2,
            )
            # Nesting is one way to handle this, but it's not ideal.
            # For simplicity and to highlight the issue, we'll just warn the user.
            # In a real-world scenario, a more robust solution might be needed.
            pass
    except RuntimeError:  # No running loop
        pass

    asyncio.run(_run_import())
